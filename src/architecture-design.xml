<?xml version="1.0" encoding="UTF-8" ?>
<?xml-stylesheet href="xsl/page.xsl" type="text/xsl" ?>

<page section="architecture">
  <heading>Architecture</heading>

  <content>

    <h1>Introduction</h1>
    
    <p>Carrot<sup>2</sup> is composed of <b>components</b> bound together
    in a <b>processing chain</b>. There are three fundamental components:</p>
    
    <ul class="compact">
        <li><p><b>input</b> <em/> anything that produces <b>snippets</b> to be
         clustered. Each snippet consists of a unique URL, a title and                               
         a fragment of text from the content of a document. Example input                            
         components available in Carrot<sup>2</sup> provide bridges to                               
         existing major search engines (Yahoo, Google), open source                                  
         search engines (Lucene), but also adapt XMLs (such as RSS or OpenSearch).                   
         As a final resort, you can try to write your own input component                            
         using the examples available in the project.</p></li>                                           
    
         <li><p><b>filters</b> <em/> typically a clustering component and a set                             
         of filters that it requires. Carrot<sup>2</sup> comes with a number                         
         of clustering components; each one implements a different algorithm                         
         and has different requirements concerning configuration and previous                        
         filters in the processing chain. You'll need to take a look at the                          
         demo applications (web application and local application) - there                           
         are full scripts configuring each clustering component there. In this                       
         example we will use <b>Lingo</b> clustering component and configure                         
         it directly from the source code.</p></li>
    
         <li><p><b>output</b> <em/> a clustering component typically produces 
         instances of <tt>RawCluster</tt> interface. The role of an output 
         component is to do something                   
         with clusters once you receive them from the clusterer. The easiest                         
         way is to save them in an array and wait until all the processing is                        
         finished (all the clusters are available). A more advanced application                      
         could use (display?) clusters as soon as they appear from the clustering                    
         component. In this example we will buffer the output clusters in                            
         an array.</p></li>                                                                                   
    </ul>

    <p style="margin-top: 0px;">We often talk about <b>local</b> components or <b>local</b>
    architecture. This distinction is for historical reasons (there was once a parallel design
    using remote communication between components, but it has been dropped.</p>


    <h1>Design goals and constraints</h1>
    
    <p style="padding-bottom: 0; margin-bottom: 1em;">The initial requirements for Carrot<sup>2</sup> design were as follows:</p>

    <ul class="morecompact">
        <li><p>Performance</p><ol class="morecompact">
            <li id="a.1" xreflabel="Local method calls"><p>local method calls</p></li>
            <li id="a.2" xreflabel="Memory/ object reuse"><p>memory/ object reuse</p></li>
            <li id="a.3" xreflabel="Direct typing"><p>direct typing (no interfaces)</p></li>
            <li id="a.4" xreflabel="Single-threaded pipelines"><p>single-threaded process pipeline</p></li>
            <li id="a.5" xreflabel="Processes in compiled code"><p>processes written in compiled code</p></li>
        </ol></li>

        <li><p>Scalability</p><ol>
            <li id="b.1" xreflabel="Component-language independence"><p>Component-language independence.</p></li>
            <li id="b.2" xreflabel="Incremental pipelines"><p>Incremental pipeline (partial processing).</p></li>
            <li id="b.3" xreflabel="Distributed processing"><p>Distributed processing.</p></li>
        </ol></li>
        
        <li><p>Flexibility (openness)</p><ol>
            <li id="c.1" xreflabel="Flexible data types"><p>The design must not restrict or limit the data types
                   passed between components (i.e. components may push in the
                   pipeline whatever they want to).</p></li>
            <li id="c.2" xreflabel="Code reuse"><p>Reuse of components and common code.</p></li>
        </ol></li>
        
        <li><p>User-friendly design</p><ol>
            <li id="d.1" xreflabel="Component compatibility verification"><p>Controller handles some of the complexity of process verification
                   (incompatible components linked in a chain).</p></li>
            <li id="d.2" xreflabel="Scripted components and processes"><p>Components and processes easily scripted without code recompilation.</p></li>
        </ol></li>
    </ul>

    <p>Many of the above goals are contradictory <em/> for example, <xref linkend="b.1" /> and <xref linkend="a.3" />, or
    <xref linkend="a.5" /> and <xref linkend="d.2" />. The suggested design emphasizes performance, but also attempts
    to preserve the flexibility that we thought was most valuable in
    the framework. From the above set of goals we have selected the following as
    driving factors for the project:</p>

    <ul class="morecompact">
        <li><p><xref linkend="a.1"/></p>
            <p>Local method calls are the key to achieving high performance. Data must not
            be passed via bounded buffers, but directly from component to component. If
            at all possible, data should be reused and not copied/ duplicated.</p>
        </li>

        <li><p><xref linkend="a.2"/></p>
            <p>Intense memory allocation/ garbage collection slows down any Java application
            by a factor of magnitude. The design must provide means to reuse intermediate
            component data from request to request.</p>
        </li>
        
        <li><p><xref linkend="a.4"/></p>
            <p>It seems that the cost of interprocess (or inter-thread) communication
            and synchronization is usually higher than the gain from parallelization.
            One request should be processed by one thread entirely.</p>
        </li>

        <li><p><xref linkend="a.5"/></p>
            <p>Process specification must be flexible at the time of development, 
            but efficient for production use.</p>
        </li>

        <li><p><xref linkend="b.2"/></p>
            <p>Components may not need all of their successors' data. Passing a single <quote>results</quote> object
            sequentially from component to component would be memory-inefficient.</p>
        </li>
        
        <li><p><xref linkend="c.1"/></p>
            <p>This is the most difficult issue: how to specify local binding interfaces without
            knowing in advance what types of data can be passed between components.
            We think the proposed design handles this issue gracefully and at the same time
            allows efficient implementations. Components <b>declare</b> their
            needs and expectations from predecessors and successors in the processing chain.
            The controller verifies if the entire processing chain is pairwise-compatible and
            then components may simply cast successors to a required Java interface.</p>
        </li>

        <li><p><xref linkend="c.2"/></p>
            <p>Components will share a common memory space, so common code sharing
            should not be a problem (unlike Web applications, which were constrained by
            sandboxed class loaders). Reusing code limits application's memory footprint
            and in effect the impact of swapping memory by the operating system.</p>
        </li>

        <li><p><xref linkend="d.2"/></p>
            <p>BeanShell 2.0-series will be used as an alternative form of providing process
            definitions (because it allows subclassing and anonymous interface
            implementations).</p>
        </li>
    </ul>

    <p style="margin-bottom: 1em;">The goals that we consider of lesser importance (or thrown away because of conflicts):</p>

    <ul class="morecompact">
        <li><p><xref linkend="a.3"/></p>
            <p>Type-checks at runtime are quite costly, but we will use interfaces anyway, because
            they provide more flexibility in designing the controller.</p>
        </li>

        <li><p><xref linkend="b.1"/></p>
            <p>Similarily to (<xref linkend="a.4"/>): we think that distributing entire atomic single-threaded
            local processes will be more efficient than distributing components. 
            If really needed, local stubs can simulate local interfaces and allow distributed processing.</p>
        </li>

        <li><p><xref linkend="b.3"/></p>
            <p>Can be achieved by using JNI wrappers. This requires more effort, but will work.</p>
        </li>

        <li><p><xref linkend="d.1"/></p>
            <p>This is a very nice feature to have, but it is in conflict with (<xref linkend="c.1"/>) and there
            seems to be no elegant way to fulfill this goal. We suggest a method of component
            compatibility verification based on explicit capabilities (declared inside
            a component), but we do not make these capabilities an obligation for
            component/ process designers.</p>
        </li>
    </ul>


    <h1>Overview of the design</h1>

    <h2>Components</h2>

    <p>A class diagram of the core classes in the local architecture is presented below (click to enlarge).</p>

    <p><a href="img/architecture/core-local-classes.png"><img class="pic" src="img/architecture/core-local-classes-small.png" 
        alt="Class diagram of the core classes in the local architecture" /></a></p>

    <p>All components must implement <tt>LocalComponent</tt> interface. 
    This interface contains methods that allow component initialization at the moment of creation,
    verification of compatibility with other components and finally, 
    lifecycle methods that allow the component to be reused by a component container.</p>
            
    <p style="margin-bottom: 1em;">The <tt>LocalComponent</tt> interface is the super interface for all three types
    of local components:</p>

    <ul class="morecompact">
        <li><p><tt>LocalInputComponent</tt> <em/>
        components accepting user queries and producing initial data.</p></li>
        
        <li><p><tt>LocalFilterComponent</tt> <em/>
        components that somehow alter or enrich the data.</p></li>
        
        <li><p><tt>LocalOutputComponent</tt> <em/>
        components gathering the result or doing something with the result.
        For example, a visual component displaying the data can implement this interface.</p></li>
    </ul>

    <p>Lifecycle of a component is regulated by a contract in <tt>LocalComponent</tt>
    interface. A state diagram for a lifecycle of a component is presented in
    the figure below. Transitions in the diagram represent callback method 
    calls from a process object (an instance of <tt>LocalProcess</tt>
    interface). All method names and the specifics of the contract are explained
    in JavaDoc documentation and are omitted here.</p>

    <p><a href="img/architecture/component-lifecycle.png"><img class="pic" src="img/architecture/component-lifecycle-small.png" 
        alt="State diagram of a lifecycle of a local component" /></a></p>

    <p>This base functionality of a component is slightly extended depending on the role of a
    component in a processing chain; input/ filter and output components are distinguished. Input
    components take an additional <tt>query</tt> argument, output components 
    provide a method for harvesting the result of a process. Filter and input components also 
    specify a very important method <tt>setNext()</tt> 
    that lets the local process to combine components in a processing chain and thus allow components
    to interact directly with each other.</p>

    <p>The above interfaces are stripped of any functional methods because these are in a different
    area of concern and are independent of the local component container and the governing process. 
    Methods specific to data processing should be provided by component designers as an
    extension to the base interfaces.
    Components must ensure at the time of processing chain linking that they can <b>understand</b>
    the successor's data-related methods, usually by attemting to cast it to a more specific type.</p>



    <h2>Component initialization</h2>

    <p>Before any processing begins, components and processes are added to a
    component container, also referred to as a controller component.
    The controller is not explicitly specified in the core framework,
    because it is mostly application-dependent and beyond the scope of
    the specification. However, a <tt>LocalControllerContext</tt> interface
    is specified and passed to each
    instantiated component. <tt>LocalControllerContext</tt> lets
    components and processes to verify compatibility with each other and provide some
    insight into the availability of other component types.</p>



    <h2>Processes</h2>

    <p>A local process embodies the logic needed to process queries and assemble
    componenents in a processing chain.
    Instances of this interface must be written by the user of the framework,
    because it is the process that decides which components are used to process
    a query in how they are connected to each other. The contract on
    the behavior of a <tt>LocalProcess</tt> instances
    is quite complex and developers are encouraged to subclass
    the reference implementation of <tt>LocalProcessBase</tt> and
    override the hook methods specified in there. Having said that, implementing
    the raw interface gives full control over the component assembly and query
    execution process.</p>

    <p>See JavaDoc for up-to-date information about the details of <tt>LocalProcess</tt> 
    implementation.</p>

    
    
    <h2>Query execution</h2>

    <p>When all processes and components are added to a controller, it is ready to
process requests. The controller passes a query request to a local process 
instance for execution using the <tt>query()</tt> method:</p>

    <pre>public void Object query(RequestContext context, String query) throws Exception;</pre>

    <p>A process can now request instances of components (this allows pooling of
component instances per-request and ensures they are always returned to the
pool), link them in a processing chain and perform the request processing.</p>

    <p>The contract on the <tt>query()</tt> method is detailed in the JavaDoc documentation
    as well.</p>   
  </content>
</page>
